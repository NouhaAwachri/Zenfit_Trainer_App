# services/structured_workout_parser.py

import re
import json
from typing import Dict, List, Optional, Tuple

def parse_structured_workout_program(program_text: str, program_id: int) -> Dict:
    """
    Parse structured workout programs with Day headers and Main Workout sections
    Specifically designed for formats like:
    ### Day 1: Title
    **Main Workout:**
    - Exercise: sets x reps, Rest: time
    """
    try:
        print(f"üéØ Parsing structured workout program for ID: {program_id}")
        print(f"üìÑ Text length: {len(program_text)} characters")
        
        # Extract all days from the program
        days_data = extract_structured_days(program_text)
        
        if not days_data:
            print("‚ö†Ô∏è No structured days found, trying fallback parsing")
            return extract_with_generic_patterns(program_text, program_id)
        
        print(f"‚úÖ Found {len(days_data)} structured days")
        
        # Transform to expected format
        result = {
            "Week 1": {}
        }
        
        for day_data in days_data:
            day_key = f"Day {day_data['day']}"
            result["Week 1"][day_key] = {
                "label": day_data["label"],
                "exercises": day_data["exercises"]
            }
        
        return add_exercise_ids(result, program_id)
        
    except Exception as e:
        print(f"‚ùå Structured parsing failed: {str(e)}")
        return extract_with_generic_patterns(program_text, program_id)

def extract_structured_days(program_text: str) -> List[Dict]:
    """Extract days with ### Day X: format"""
    days = []
    
    # Pattern to match day headers: ### Day 1: Title
    day_pattern = r'###\s*Day\s*(\d+)\s*:\s*(.+?)(?:\n|$)'
    day_matches = list(re.finditer(day_pattern, program_text, re.IGNORECASE))
    
    print(f"üîç Found {len(day_matches)} day headers")
    
    for i, match in enumerate(day_matches):
        day_num = int(match.group(1))
        day_title = match.group(2).strip()
        
        # Get content between this day and next day (or end of text)
        start_pos = match.end()
        if i + 1 < len(day_matches):
            end_pos = day_matches[i + 1].start()
        else:
            end_pos = len(program_text)
        
        day_content = program_text[start_pos:end_pos]
        
        print(f"üìã Processing Day {day_num}: {day_title}")
        print(f"   Content length: {len(day_content)} chars")
        
        # Extract exercises from this day's content
        exercises = extract_main_workout_exercises(day_content)
        
        if exercises:
            days.append({
                "day": day_num,
                "label": day_title,
                "exercises": exercises
            })
            print(f"   ‚úÖ Found {len(exercises)} exercises")
        else:
            print(f"   ‚ö†Ô∏è No exercises found in Day {day_num}")
    
    return days

def extract_main_workout_exercises(day_content: str) -> List[Dict]:
    """Extract exercises from the Main Workout section of a day"""
    exercises = []
    
    # Look for Main Workout section
    main_workout_pattern = r'\*\*Main\s+Workout[^:]*:\*\*\s*(?:\([^)]*\))?\s*(.*?)(?=\*\*\w+|\Z)'
    main_workout_match = re.search(main_workout_pattern, day_content, re.IGNORECASE | re.DOTALL)
    
    if main_workout_match:
        workout_content = main_workout_match.group(1)
        print(f"   üéØ Found Main Workout section: {len(workout_content)} chars")
    else:
        # If no explicit Main Workout section, use the whole content but skip warm-up/cool-down
        print("   üîç No Main Workout section found, parsing entire day content")
        # Remove warm-up and cool-down sections
        content_cleaned = re.sub(r'\*\*(?:Warm-up|Cool-down)[^:]*:\*\*.*?(?=\*\*|\Z)', '', day_content, flags=re.IGNORECASE | re.DOTALL)
        workout_content = content_cleaned
    
    # Extract individual exercises
    exercises = parse_exercise_lines(workout_content)
    
    return exercises

def parse_exercise_lines(workout_content: str) -> List[Dict]:
    """Parse individual exercise lines from workout content"""
    exercises = []
    
    # Pattern to match exercise lines:
    # - Push-Ups: 4 sets x 15 reps, Rest: 60 seconds
    # - Squats: 4 sets x 12 reps, Rest: 60 seconds
    # - Planks: 4 sets x 30 seconds, Rest: 60 seconds
    
    exercise_patterns = [
        # Pattern 1: "- Exercise: X sets x Y reps, Rest: Z seconds"
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*sets?\s*x\s*(\d+)\s*(?:reps?|seconds?)\s*,?\s*(?:Rest:\s*(\d+)\s*seconds?)?',
        
        # Pattern 2: "- Exercise: X sets x Y reps per leg, Rest: Z seconds"
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*sets?\s*x\s*(\d+)\s*(?:reps?|seconds?)\s*(?:per\s+leg)?\s*,?\s*(?:Rest:\s*(\d+)\s*seconds?)?',
        
        # Pattern 3: "- Exercise: X sets of Y reps, Rest: Z seconds"
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*sets?\s*of\s*(\d+)\s*(?:reps?|seconds?)\s*,?\s*(?:Rest:\s*(\d+)\s*seconds?)?',
        
        # Pattern 4: Simple "- Exercise: X sets x Y reps"
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*sets?\s*x\s*(\d+)\s*(?:reps?|seconds?)',
        
        # Pattern 5: "- Exercise: X x Y"  
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*x\s*(\d+)',
        
        # Pattern 6: For time-based exercises like "Planks: 4 sets x 30 seconds"
        r'-\s*([A-Za-z][A-Za-z\s\-\(\)]+?)\s*:\s*(\d+)\s*sets?\s*x\s*(\d+)\s*seconds?'
    ]
    
    lines = workout_content.split('\n')
    
    for line in lines:
        line = line.strip()
        if len(line) < 5:
            continue
        
        # Skip lines that don't look like exercises
        if any(skip in line.lower() for skip in ['warm', 'cool', 'rest:', 'note', 'tip', 'hold for']):
            continue
        
        # Try each pattern
        for pattern in exercise_patterns:
            match = re.search(pattern, line, re.IGNORECASE)
            if match:
                name = match.group(1).strip()
                sets = int(match.group(2))
                reps_or_seconds = int(match.group(3))
                
                # Extract rest time if captured
                rest_seconds = 60  # default
                try:
                    if match.group(4):  # Rest time captured
                        rest_seconds = int(match.group(4))
                except (IndexError, ValueError):
                    pass
                
                # Clean up exercise name
                name = clean_exercise_name(name)
                
                # Validate exercise
                if len(name) > 2 and sets > 0 and reps_or_seconds > 0:
                    exercise = {
                        "name": name,
                        "sets": sets,
                        "reps": reps_or_seconds,
                        "rest_seconds": rest_seconds
                    }
                    exercises.append(exercise)
                    print(f"      ‚úÖ Parsed: {name} - {sets}x{reps_or_seconds}, Rest: {rest_seconds}s")
                    break  # Found a match, don't try other patterns
    
    return exercises

def clean_exercise_name(name: str) -> str:
    """Clean up exercise name"""
    # Remove extra whitespace and formatting
    name = re.sub(r'\s+', ' ', name).strip()
    
    # Remove trailing punctuation
    name = re.sub(r'[:\-,\.]+$', '', name).strip()
    
    # Capitalize properly
    if name:
        name = name[0].upper() + name[1:].lower()
        # Capitalize after spaces and dashes
        name = re.sub(r'(\s+|-)([a-z])', lambda m: m.group(1) + m.group(2).upper(), name)
    
    return name

def extract_with_generic_patterns(program_text: str, program_id: int) -> Dict:
    """Fallback generic pattern extraction"""
    print("üîÑ Using generic pattern extraction")
    
    # Look for any exercise-like patterns in the entire text
    all_exercises = []
    
    # Generic patterns for exercises anywhere in text
    generic_patterns = [
        r'([A-Za-z][A-Za-z\s\-]+?)\s*:\s*(\d+)\s*sets?\s*x\s*(\d+)\s*(?:reps?|seconds?)',
        r'([A-Za-z][A-Za-z\s\-]+?)\s*:\s*(\d+)\s*x\s*(\d+)',
        r'-\s*([A-Za-z][A-Za-z\s\-]+?):\s*(\d+)\s*sets?\s*x\s*(\d+)',
    ]
    
    for pattern in generic_patterns:
        matches = re.finditer(pattern, program_text, re.IGNORECASE)
        for match in matches:
            name = clean_exercise_name(match.group(1))
            sets = int(match.group(2))
            reps = int(match.group(3))
            
            # Skip if already found or invalid
            if (len(name) > 2 and sets > 0 and reps > 0 and 
                not any(ex['name'].lower() == name.lower() for ex in all_exercises)):
                
                all_exercises.append({
                    "name": name,
                    "sets": sets,
                    "reps": reps,
                    "rest_seconds": 60
                })
    
    print(f"üîç Generic extraction found {len(all_exercises)} unique exercises")
    
    if all_exercises:
        return add_exercise_ids({
            "Week 1": {
                "Day 1": {
                    "label": "Full Body Workout",
                    "exercises": all_exercises[:10]  # Limit to 10
                }
            }
        }, program_id)
    else:
        # Ultimate fallback
        return add_exercise_ids({
            "Week 1": {
                "Day 1": {
                    "label": "Basic Workout",
                    "exercises": [
                        {"name": "Push-Ups", "sets": 3, "reps": 10, "rest_seconds": 60},
                        {"name": "Squats", "sets": 3, "reps": 12, "rest_seconds": 60},
                        {"name": "Plank", "sets": 3, "reps": 30, "rest_seconds": 60}
                    ]
                }
            }
        }, program_id)

def add_exercise_ids(parsed_data, program_id):
    """Add unique IDs and completion status to exercises"""
    for week_key, week_data in parsed_data.items():
        week_num = int(week_key.replace("Week ", ""))
        for day_key, day_data in week_data.items():
            day_num = int(day_key.replace("Day ", ""))
            exercises = day_data.get("exercises", [])
            
            for idx, exercise in enumerate(exercises):
                exercise["id"] = f"{program_id}_{week_num}_{day_num}_{idx}"
                exercise["completed"] = False
                exercise["notes"] = ""
    
    return parsed_data

def validate_parsed_data(parsed_data):
    """Validate that parsed data has the expected structure"""
    try:
        if not isinstance(parsed_data, dict):
            return False
        
        # Check for at least one week
        week_keys = [key for key in parsed_data.keys() if key.startswith("Week")]
        if not week_keys:
            return False
        
        # Check first week structure
        first_week = parsed_data[week_keys[0]]
        if not isinstance(first_week, dict):
            return False
        
        # Check for at least one day
        day_keys = [key for key in first_week.keys() if key.startswith("Day")]
        if not day_keys:
            return False
        
        # Check first day structure
        first_day = first_week[day_keys[0]]
        if not isinstance(first_day, dict) or "exercises" not in first_day:
            return False
        
        # Check for at least one exercise
        exercises = first_day["exercises"]
        if not isinstance(exercises, list) or len(exercises) == 0:
            return False
        
        # Validate first exercise
        first_exercise = exercises[0]
        required_fields = ["name", "sets", "reps"]
        if not all(field in first_exercise for field in required_fields):
            return False
        
        return True
        
    except Exception:
        return False